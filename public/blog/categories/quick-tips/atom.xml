<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Quick Tips | Spring in Practice]]></title>
  <link href="http://springinpractice.com/blog/categories/quick-tips/atom.xml" rel="self"/>
  <link href="http://springinpractice.com/"/>
  <updated>2013-10-07T02:07:53-07:00</updated>
  <id>http://springinpractice.com/</id>
  <author>
    <name><![CDATA[Willie Wheeler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Handling JSON error object responses with Spring's RestTemplate]]></title>
    <link href="http://springinpractice.com/2013/10/07/handling-json-error-object-responses-with-springs-resttemplate/"/>
    <updated>2013-10-07T01:14:00-07:00</updated>
    <id>http://springinpractice.com/2013/10/07/handling-json-error-object-responses-with-springs-resttemplate</id>
    <content type="html"><![CDATA[<p>Some web services return JSON error objects when there&rsquo;s a problem. <a href="http://developer.github.com/v3/#client-errors">GitHub&rsquo;s API</a> is a good case in point, but the approach is not uncommon. Error objects give the API a way to communicate details beyond what the HTTP status codes indicate.</p>

<p>A challenge when using Spring&rsquo;s <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a> is that there&rsquo;s not an obvious way to handle these. Normally when we use the <code>RestTemplate</code>, we indicate a specific type of response payload we expect to see, and so if an error object comes back instead, then it&rsquo;s not clear what to do.</p>

<p>One possible approach is to add error fields to the various resource data transfer objects (DTOs). While this can work, I&rsquo;m not a big fan of this approach as it fails to separate the resource modeling and error reporting concerns, which I take to be distinct.</p>

<p>So let&rsquo;s look at a different approach&mdash;one that does in fact separate resource modeling from error reporting.</p>

<h2>The idea</h2>

<p>The concept is to read the response body as a string instead of reading it as an object, and then deserialize the body either as the expected response type or else as an error object, depending on whether the status code was in the HTTP 400 or 500 series (client and server errors, respectively).</p>

<h2>How to do it</h2>

<p>First we need a special <code>RestTemplate</code> configuration. By default <code>RestTemplate</code> contains a default <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/client/ResponseErrorHandler.html">ResponseErrorHandler</a> implementation called <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/client/DefaultResponseErrorHandler.html">DefaultResponseErrorHandler</a>, which throws an exception when there&rsquo;s an HTTP error. This doesn&rsquo;t work for us, because the exception bubbles out of the <code>RestTemplate</code> call, thus abandoning the error object we want to read. So we just need to replace it with a custom handler that doesn&rsquo;t throw the exception. Here&rsquo;s one:</p>

<pre><code>package myapp.client;

import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.web.client.ResponseErrorHandler;
import myapp.util.RestUtil;

public class MyResponseErrorHandler implements ResponseErrorHandler {
    private static final Logger log = LoggerFactory.getLogger(MyResponseErrorHandler.class);

    @Override
    public void handleError(ClientHttpResponse response) throws IOException {
        log.error("Response error: {} {}", response.getStatusCode(), response.getStatusText());
    }

    @Override
    public boolean hasError(ClientHttpResponse response) throws IOException {
        return RestUtil.isError(response.getStatusCode());
    }
}
</code></pre>

<p>In the code above, the <code>handleError()</code> method simply logs the error. It doesn&rsquo;t throw an exception, since again we don&rsquo;t want to prevent <code>RestTemplate</code> from reading the error object into a string.</p>

<p>Just for completeness, here&rsquo;s <code>RestUtil</code>:</p>

<pre><code>package myapp.util;

import org.springframework.http.HttpStatus;

public class RestUtil {

    public static boolean isError(HttpStatus status) {
        HttpStatus.Series series = status.series();
        return (HttpStatus.Series.CLIENT_ERROR.equals(series) || HttpStatus.Series.SERVER_ERROR.equals(series));
    }
}
</code></pre>

<p>Now we need to configure the <code>RestTemplate</code> to use our custom <code>ResponseErrorHandler</code>:</p>

<pre><code>&lt;bean class="org.springframework.web.client.RestTemplate"&gt;
    &lt;property name="errorHandler"&gt;
        &lt;bean class="myapp.client.MyResponseErrorHandler" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>We&rsquo;re going to need an object mapper too (I&rsquo;m assuming <a href="http://wiki.fasterxml.com/JacksonHome">Jackson 2</a> here, though in principle the same approach should work for JAXB or Jackson 1 as well). So here&rsquo;s that:</p>

<pre><code>&lt;bean id="objectMapper" class="com.fasterxml.jackson.databind.ObjectMapper" /&gt;
</code></pre>

<p>Inject the <code>RestTemplate</code> and <code>ObjectMapper</code> into your client code. Now here&rsquo;s how to use them to deal with error objects:</p>

<pre><code>@Inject private RestTemplate restTemplate;
@Inject private ObjectMapper objectMapper;

public DoodadResources getDoodads() {
    HttpHeaders headers = new HttpHeaders();
    headers.add("Accept", MediaType.APPLICATION_JSON_VALUE);
    HttpEntity&lt;String&gt; request = new HttpEntity&lt;String&gt;(headers);
    ResponseEntity&lt;String&gt; response = restTemplate.exchange(DOODAD_URL, HttpMethod.GET, request, String.class);
    String responseBody = response.getBody();
    try {
        if (RestUtil.isError(response.getStatusCode())) {
            MyErrorResource error = objectMapper.readValue(responseBody, MyErrorResource.class);
            throw new RestClientException("[" + error.getCode() + "] " + error.getMessage());
        } else {
            DoodadResources doodads = objectMapper.readValue(responseBody, DoodadResources.class);
            return doodads;
        }
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
</code></pre>

<p>Notice that the call to <code>exchange()</code> specifies that we want to map the response body to a string, which can handle any JSON (or XML) response. Then we use <code>RestUtil</code> again to process the response differently depending on the status series. For errors we parse the response body into a <code>MyErrorResource</code> and use it to throw an exception with an app-specific error code (not simply an HTTP status code) and a descriptive message. Of course we can do whatever we want with the detailed error information; this is just an example.</p>

<p>If there&rsquo;s no error, then we can parse the response body into the expected response type, if there is one, and return it. Here we return a <code>DoodadResources</code>.</p>

<p>That&rsquo;s at least one way to do it. If you have a better way, I&rsquo;d be interested to hear about it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick tip: Basic authentication with Spring RestTemplate]]></title>
    <link href="http://springinpractice.com/2013/10/02/quick-tip-basic-authentication-with-spring-resttemplate/"/>
    <updated>2013-10-02T02:10:00-07:00</updated>
    <id>http://springinpractice.com/2013/10/02/quick-tip-basic-authentication-with-spring-resttemplate</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s a quick tip for using Spring&rsquo;s <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a> to authenticate to a RESTful web service that uses <a href="http://en.wikipedia.org/wiki/Basic_access_authentication">HTTP basic authentication</a>.</p>

<p>There are a couple of things we have to do:</p>

<ul>
<li>First we construct an <code>Authorization</code> request header that contains (among other things) the user&rsquo;s base 64-encoded credentials.</li>
<li>Then we invoke the <code>RestTemplate</code> in such a way as to send that request header to the service.</li>
</ul>


<!-- more -->


<p>Let&rsquo;s start with the <code>Authorization</code> header.</p>

<h2>Authorization header</h2>

<p>For the sake of example, suppose that the username is <code>willie</code> and the password is <code>p@ssword</code>.</p>

<p>The first step is to base 64 encode the string <code>willie:p@ssword</code>. In general we want to do this programmatically. The <a href="http://commons.apache.org/proper/commons-codec/">Apache Commons Codec library</a> is useful for doing this:</p>

<pre><code>import org.apache.commons.codec.binary.Base64;

...

String plainCreds = "willie:p@ssword";
byte[] plainCredsBytes = plainCreds.getBytes();
byte[] base64CredsBytes = Base64.encodeBase64(plainCredsBytes);
String base64Creds = new String(base64CredsBytes);
</code></pre>

<p>Now let&rsquo;s construct our HTTP request headers, including the <code>Authorization</code> header:</p>

<pre><code>import org.springframework.http.HttpHeaders;

...

HttpHeaders headers = new HttpHeaders();
headers.add("Authorization", "Basic " + base64Creds);
</code></pre>

<p>Next, let&rsquo;s use the <code>RestTemplate</code> to issue the request.</p>

<h2>Using RestTemplate to send the request</h2>

<p>The approach is similar to what we did with <a href="http://springinpractice.com/2012/04/08/sending-cookies-with-resttemplate/">Sending Cookies with RestTemplate</a>. We use one of the <code>RestTemplate</code>&rsquo;s <code>exchange()</code> methods to exchange a request for a response. Let&rsquo;s imagine that we want to get account information.</p>

<pre><code>import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

...

HttpEntity&lt;String&gt; request = new HttpEntity&lt;String&gt;(headers);
ResponseEntity&lt;Account&gt; response = restTemplate.exchange(url, HttpMethod.GET, request, Account.class);
Account account = response.getBody();
</code></pre>

<p>In both the request and response, the type parameters represent the body. In the request we aren&rsquo;t sending anything in the body, so we just use <code>String</code> as a default, and pass the headers along by themselves. In the response we expect an account, so that&rsquo;s why we have <code>Account</code> and <code>Account.class</code> there.</p>

<p>Happy basic authenticating.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aggregating TP90 data with Splunk]]></title>
    <link href="http://springinpractice.com/2013/09/25/aggregating-tp90-data-with-splunk/"/>
    <updated>2013-09-25T19:38:00-07:00</updated>
    <id>http://springinpractice.com/2013/09/25/aggregating-tp90-data-with-splunk</id>
    <content type="html"><![CDATA[<p>One of the challenges around <a href="http://stackoverflow.com/questions/17435438/what-do-we-mean-by-top-percentile-or-tp-based-latency">TP90</a> data is aggregating it. I wrote about this <a href="http://stats.stackexchange.com/questions/49017/options-for-aggregating-dispersion-data">here</a>, and offered a solution based on histograms. Here I&rsquo;m going to describe another approach, this time based on weighted averages.</p>

<!-- more -->


<p>To be concrete, suppose we have web page response times, and we&rsquo;ve computed hourly TP90s for them. Now we want to know the TP90 for a week. To get the exact answer, we&rsquo;d need to look at all the response times for the whole week, but that can be pretty expensive for a busy site. The challenge is to estimate the week&rsquo;s TP90 based on the hourlies.</p>

<p>We can do that by computing a <a href="http://en.wikipedia.org/wiki/Weighted_arithmetic_mean">weighted average</a>, where we use counts to establish weights. The weight for any given hour is the number of requests that hour divided by the total number of requests that week. Apply the hourly weights to the hourly TP90s and then sum them all up to get the weighted average over the week.</p>

<p>Here&rsquo;s how to do it in <a href="http://www.splunk.com/">Splunk</a>. The trick here is the <a href="http://docs.splunk.com/Documentation/Splunk/5.0.5/SearchReference/Eventstats">eventstats</a> command, which makes the sum of the hourly counts available on a per-row basis so we can use it to calculate weights.</p>

<pre><code>index=webRequestSummary earliest=-7d@d latest=@d
    | eventstats sum(hourlyCount) as totalCount
    | eval weight = hourlyCount / totalCount
    | eval weightedHourlyTP90 = weight * hourlyTP90
    | sum(weightedHourlyTP90) as weightedAvgTP90
</code></pre>

<p>That&rsquo;s it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Renaming node classes when using Spring Data Neo4j]]></title>
    <link href="http://springinpractice.com/2012/12/09/renaming-node-classes-when-using-spring-data-neo4j/"/>
    <updated>2012-12-09T15:33:00-08:00</updated>
    <id>http://springinpractice.com/2012/12/09/renaming-node-classes-when-using-spring-data-neo4j</id>
    <content type="html"><![CDATA[<p>This is one of those posts where I&rsquo;m just jotting down some notes for my own future use, but someone else may find this useful.</p>

<p>I&rsquo;m going to show how to rename a node entity class when using Spring Data Neo4j. I&rsquo;m talking about the fully-qualified classname here, so it applies when we want to rename a package too.</p>

<!-- more -->


<p>First, suppose my old classname is <code>org.zkybase.cmdb.api.domain.ApplicationEntity</code>. If I go into the Neo4j shell, I can see that I have a couple of nodes of this type:</p>

<pre><code>neo4j-sh (0)$ start n=node:__types__(className="org.zkybase.cmdb.api.domain.ApplicationEntity") return n
+-----------------------------------------------------------------------------------------------------+
| n                                                                                                   |
+-----------------------------------------------------------------------------------------------------+
| Node[36]{__type__-&gt;"org.zkybase.cmdb.api.domain.ApplicationEntity",name-&gt;"Zkybase"}                 |
| Node[49]{name-&gt;"Spring in Practice Blog",__type__-&gt;"org.zkybase.cmdb.api.domain.ApplicationEntity"} |
+-----------------------------------------------------------------------------------------------------+
2 rows, 1 ms
</code></pre>

<p>From the above, it <i>looks like</i> you can just go to the nodes themselves and change their <code>__type__</code> fields:</p>

<pre><code>neo4j-sh (0)$ cd -a 36
neo4j-sh (Zkybase,36)$ ls
*__type__ =[org.zkybase.cmdb.api.domain.ApplicationEntity]
*name     =[Zkybase]
neo4j-sh (Zkybase,36)$ set __type__ "org.zkybase.api.domain.entity.ApplicationEntity"
neo4j-sh (Zkybase,36)$ ls
*__type__ =[org.zkybase.api.domain.entity.ApplicationEntity]
*name     =[Zkybase]
</code></pre>

<p>But then when you try to find the node using the query, it doesn&rsquo;t show up.</p>

<pre><code>neo4j-sh (Zkybase,36)$ start n=node:__types__(className="org.zkybase.api.domain.entity.ApplicationEntity") return n
+---+
| n |
+---+
+---+
0 rows, 1 ms
</code></pre>

<p>Moreover, when you re-run the original query, the node whose <code>__type__</code> we changed still shows up.</p>

<p>The problem is that we need to reindex the nodes. Spring Data Neo4j uses an index called <code>__types__</code>, and we need to replace the old index entries with some new ones.</p>

<p>Let&rsquo;s see what&rsquo;s under the old classname, using <code>index -g</code> to get the relevant nodes from the <code>__types__</code> index:</p>

<pre><code>neo4j-sh (Zkybase,36)$ index -g __types__ className "org.zkybase.cmdb.api.domain.ApplicationEntity"
(me)

(Spring in Practice Blog,49)
</code></pre>

<p>And under the new classname:</p>

<pre><code>neo4j-sh (Zkybase,36)$ index -g __types__ className "org.zkybase.api.domain.entity.ApplicationEntity"
neo4j-sh (Zkybase,36)$ 
</code></pre>

<p>We can fix that using <code>index -i</code>, which indexes the current entity:</p>

<pre><code>neo4j-sh (Zkybase,36)$ index -i __types__ className "org.zkybase.api.domain.entity.ApplicationEntity"
neo4j-sh (Zkybase,36)$ cd -a 49
neo4j-sh (Spring in Practice Blog,49)$ index -i __types__ className "org.zkybase.api.domain.entity.ApplicationEntity"
neo4j-sh (Spring in Practice Blog,49)$ cd -a 36
neo4j-sh (Zkybase,36)$ index -g __types__ className "org.zkybase.api.domain.entity.ApplicationEntity"
(me)

(Spring in Practice Blog,49)
</code></pre>

<p>We still need to clean up the old entries, though, because they&rsquo;re still there. We use <code>index -r</code> to remove the index entry for the current node:</p>

<pre><code>neo4j-sh (Zkybase,36)$ index -r __types__ className "org.zkybase.cmdb.api.domain.ApplicationEntity"
neo4j-sh (Zkybase,36)$ cd -a 49
neo4j-sh (Spring in Practice Blog,49)$ index -r __types__ className "org.zkybase.cmdb.api.domain.ApplicationEntity"
neo4j-sh (Spring in Practice Blog,49)$ index -g __types__ className "org.zkybase.cmdb.api.domain.ApplicationEntity"
neo4j-sh (Spring in Practice Blog,49)$ 
</code></pre>

<p>That&rsquo;s it. This was the result of about 15 minutes of investigation, so there&rsquo;s a good chance there&rsquo;s more going on than what I&rsquo;ve described. Let me know and I&rsquo;ll update the post accordingly.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pageable custom queries with Spring Data JPA]]></title>
    <link href="http://springinpractice.com/2012/06/30/pageable-custom-queries-with-spring-data-jpa/"/>
    <updated>2012-06-30T12:41:00-07:00</updated>
    <id>http://springinpractice.com/2012/06/30/pageable-custom-queries-with-spring-data-jpa</id>
    <content type="html"><![CDATA[<p>In previous posts I explained how you can use Spring Data JPA to <a href="http://springinpractice.com/2012/04/24/autogenerate-daos-and-queries-using-spring-data-jpa/">create repositories that support custom queries</a>, as well as to <a href="http://springinpractice.com/2012/05/11/pagination-and-sorting-with-spring-data-jpa/">support paging in your app</a>. You might wonder whether you can use these together.</p>

<p>The answer is yes. It works just like you would expect:</p>

<pre><code>import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface IncidentRepo extends JpaRepository&lt;Incident, Long&gt; {

    Page&lt;Incident&gt; findByProblemId(Long problemId, Pageable pageable);
}
</code></pre>
]]></content>
  </entry>
  
</feed>
