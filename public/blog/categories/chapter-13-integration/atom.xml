<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chapter 13 - Integration | Spring in Practice]]></title>
  <link href="http://springinpractice.com/blog/categories/chapter-13-integration/atom.xml" rel="self"/>
  <link href="http://springinpractice.com/"/>
  <updated>2013-10-09T01:31:48-07:00</updated>
  <id>http://springinpractice.com/</id>
  <author>
    <name><![CDATA[Willie Wheeler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Generating JSON error object responses with Spring Web MVC]]></title>
    <link href="http://springinpractice.com/2013/10/09/generating-json-error-object-responses-with-spring-web-mvc/"/>
    <updated>2013-10-09T00:39:00-07:00</updated>
    <id>http://springinpractice.com/2013/10/09/generating-json-error-object-responses-with-spring-web-mvc</id>
    <content type="html"><![CDATA[<p>The other day I wrote a post called <a href="http://springinpractice.com/2013/10/07/handling-json-error-object-responses-with-springs-resttemplate/">Handling JSON error object responses with Spring&rsquo;s RestTemplate</a>. Judging by the Twitter activity, people found it useful, so this time around I&rsquo;m going to write about the other side of the equation, which is <em>generating</em> the JSON error objects using Spring Web MVC. Something like this:</p>

<pre><code>{
  "code": "InvalidRequest",
  "message": "Invalid doodad",
  "fieldErrors": [
    {
      "resource": "doodadResource",
      "field": "key",
      "code": "NotNull",
      "message": "may not be null"
    },
    {
      "resource": "doodadResource",
      "field": "name",
      "code": "NotNull",
      "message": "may not be null"
    }
  ]
}
</code></pre>

<p>There are various ways to do this, but Spring 3.2 introduces a pretty elegant approach via the <code>@ControllerAdvice</code> annotation. The basic concept here is that we can define AOP-like &ldquo;advice&rdquo; around Spring Web MVC controllers. This advice captures exceptions and then maps them to JSON objects, which the advice sends in the response body. Of course we can also send the appropriate HTTP status code in the headers too.</p>

<!-- more -->


<p>(You can find out more about <code>@ControllerAdvice</code> and <code>@ExceptionHandler</code> in the post <a href="http://www.baeldung.com/2013/01/31/exception-handling-for-rest-with-spring-3-2/">Error Handling for REST with Spring 3</a> by Eugen Paraschiv.)</p>

<p>Note that the error-triggering event doesn&rsquo;t really have to be an exception <em>per se</em>. For example, we might want bean validation errors or authorization errors&mdash;neither of which manifests itself as an exception&mdash;to map to JSON error objects. The key is to have these triggers generate exceptions that we can capture using the <code>@ControllerAdvice</code> component.</p>

<p>Let&rsquo;s look at an example involving bean validation. Here we have a controller. If the incoming resource is invalid, we want to generate a JSON error object. So first we do this:</p>

<pre><code>package myapp.web.controller;

... various imports ...

@Controller
@RequestMapping("/doodads")
public class DoodadController {
    @Inject private DoodadService doodadService;

    @RequestMapping(
            value = "/{id}",
            method = RequestMethod.PUT,
            consumes = MediaType.APPLICATION_JSON_VALUE)
    public void updateDoodad(
            @PathVariable Long id,
            @RequestBody @Valid DoodadResource doodad,
            BindingResult bindingResult) {

        if (bindingResult.hasErrors()) {
            throw new InvalidRequestException("Invalid doodad", bindingResult);
        }

        doodadService.updateDoodad(doodad);
    }   
}
</code></pre>

<p>Note that <code>InvalidRequestException</code> is just a custom exception I created that takes an <code>Errors</code> object as an argument. (<code>BindingResult</code> implements <code>Errors</code>.) Just for completeness, here&rsquo;s <code>InvalidRequestException</code>:</p>

<pre><code>package myapp.exception;

import org.springframework.validation.Errors;

@SuppressWarnings("serial")
public class InvalidRequestException extends RuntimeException {
    private Errors errors;

    public InvalidRequestException(String message, Errors errors) {
        super(message);
        this.errors = errors;
    }

    public Errors getErrors() { return errors; }
}
</code></pre>

<p>So far so good. But now we need that <code>@ControllerAdvice</code> to capture the <code>InvalidRequestException</code> and generate the JSON error object:</p>

<pre><code>package myapp.web.controller;

import java.util.ArrayList;
import java.util.List;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import myapp.binding.ErrorResource;
import myapp.binding.FieldErrorResource;
import myapp.exception.InvalidRequestException;

@ControllerAdvice
public class MyExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler({ InvalidRequestException.class })
    protected ResponseEntity&lt;Object&gt; handleInvalidRequest(RuntimeException e, WebRequest request) {
        InvalidRequestException ire = (InvalidRequestException) e;
        List&lt;FieldErrorResource&gt; fieldErrorResources = new ArrayList&lt;&gt;();

        List&lt;FieldError&gt; fieldErrors = ire.getErrors().getFieldErrors();
        for (FieldError fieldError : fieldErrors) {
            FieldErrorResource fieldErrorResource = new FieldErrorResource();
            fieldErrorResource.setResource(fieldError.getObjectName());
            fieldErrorResource.setField(fieldError.getField());
            fieldErrorResource.setCode(fieldError.getCode());
            fieldErrorResource.setMessage(fieldError.getDefaultMessage());
            fieldErrorResources.add(fieldErrorResource);
        }

        ErrorResource error = new ErrorResource("InvalidRequest", ire.getMessage());
        error.setFieldErrors(fieldErrorResources);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        return handleExceptionInternal(e, error, headers, HttpStatus.UNPROCESSABLE_ENTITY, request);
    }

    ... other handlers for other exceptions ...
}
</code></pre>

<p>The important pieces here are <code>@ControllerAdvice</code> (which derives from <code>@Controller</code>, so we can component scan it), <code>ResponseEntityExceptionHandler</code> (provides the <code>handleExceptionInternal()</code> method), and <code>@ExceptionHandler</code> annotation. <code>@ExceptionHandler</code> accepts an array of match exceptions, and then its implementation builds the JSON error object, which here involves custom <code>ErrorResource</code> and <code>FieldErrorResource</code> beans that can be whatever we want to display to the client. Finally we pass response-related information to <code>handleExceptionInternal()</code>, where the error object ends up as the response body. Here we&rsquo;re using &ldquo;Unprocessable Entity&rdquo; (HTTP 422), a WebDAV extension to HTTP, since &ldquo;Bad Request&rdquo; (HTTP 400) is for syntactic rather than semantic errors. (See <a href="http://www.bennadel.com/blog/2434-HTTP-Status-Codes-For-Invalid-Data-400-vs-422.htm">HTTP Status Codes For Invalid Data: 400 vs. 422</a> by Ben Nadel for more information.)</p>

<p>Again in the interest of completeness, here are the error objects I&rsquo;m using. These are just examples of what&rsquo;s possible; choose error representations that fit your needs. First, the top-level error object:</p>

<pre><code>package myapp.binding;

import java.util.List;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class ErrorResource {
    private String code;
    private String message;
    private List&lt;FieldErrorResource&gt; fieldErrors;

    public ErrorResource() { }

    public ErrorResource(String code, String message) {
        this.code = code;
        this.message = message;
    }

    public String getCode() { return code; }

    public void setCode(String code) { this.code = code; }

    public String getMessage() { return message; }

    public void setMessage(String message) { this.message = message; }

    public List&lt;FieldErrorResource&gt; getFieldErrors() { return fieldErrors; }

    public void setFieldErrors(List&lt;FieldErrorResource&gt; fieldErrors) {
        this.fieldErrors = fieldErrors;
    }
}
</code></pre>

<p>And finally here&rsquo;s a class for field errors:</p>

<pre><code>package myapp.binding;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class FieldErrorResource {
    private String resource;
    private String field;
    private String code;
    private String message;

    public String getResource() { return resource; }

    public void setResource(String resource) { this.resource = resource; }

    public String getField() { return field; }

    public void setField(String field) { this.field = field; }

    public String getCode() { return code; }

    public void setCode(String code) { this.code = code; }

    public String getMessage() { return message; }

    public void setMessage(String message) { this.message = message; }
}
</code></pre>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling JSON error object responses with Spring's RestTemplate]]></title>
    <link href="http://springinpractice.com/2013/10/07/handling-json-error-object-responses-with-springs-resttemplate/"/>
    <updated>2013-10-07T01:14:00-07:00</updated>
    <id>http://springinpractice.com/2013/10/07/handling-json-error-object-responses-with-springs-resttemplate</id>
    <content type="html"><![CDATA[<p>Some web services return JSON error objects when there&rsquo;s a problem. <a href="http://developer.github.com/v3/#client-errors">GitHub&rsquo;s API</a> is a good case in point, and <a href="https://www.hipchat.com/docs/api">HipChat&rsquo;s API</a> does the same thing. The approach is pretty common. Error objects give the API a way to communicate details beyond what the HTTP status codes indicate.</p>

<p>A challenge when using Spring&rsquo;s <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a> is that there&rsquo;s not an obvious way to handle these. Normally when we use the <code>RestTemplate</code>, we indicate a specific type of response payload we expect to see, and so if an error object comes back instead, then it&rsquo;s not clear what to do.</p>

<p>One possible approach is to add error fields to the various resource data transfer objects (DTOs). While this can work, I&rsquo;m not a big fan of this approach as it fails to separate the resource modeling and error reporting concerns, which I take to be distinct.</p>

<p>So let&rsquo;s look at a different approach&mdash;one that does in fact separate resource modeling from error reporting.</p>

<!-- more -->


<h2>The idea</h2>

<p>The concept is to read the response body as a string instead of reading it as an object, and then deserialize the body either as the expected response type or else as an error object, depending on whether the status code was in the HTTP 400 or 500 series (client and server errors, respectively).</p>

<h2>How to do it</h2>

<p>First we need a special <code>RestTemplate</code> configuration. By default <code>RestTemplate</code> contains a default <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/client/ResponseErrorHandler.html">ResponseErrorHandler</a> implementation called <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/client/DefaultResponseErrorHandler.html">DefaultResponseErrorHandler</a>, which throws an exception when there&rsquo;s an HTTP error. This doesn&rsquo;t work for us, because the exception bubbles out of the <code>RestTemplate</code> call, thus abandoning the error object we want to read. So we just need to replace it with a custom handler that doesn&rsquo;t throw the exception. Here&rsquo;s one:</p>

<pre><code>package myapp.client;

import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.web.client.ResponseErrorHandler;
import myapp.util.RestUtil;

public class MyResponseErrorHandler implements ResponseErrorHandler {
    private static final Logger log = LoggerFactory.getLogger(MyResponseErrorHandler.class);

    @Override
    public void handleError(ClientHttpResponse response) throws IOException {
        log.error("Response error: {} {}", response.getStatusCode(), response.getStatusText());
    }

    @Override
    public boolean hasError(ClientHttpResponse response) throws IOException {
        return RestUtil.isError(response.getStatusCode());
    }
}
</code></pre>

<p>In the code above, the <code>handleError()</code> method simply logs the error. It doesn&rsquo;t throw an exception, since again we don&rsquo;t want to prevent <code>RestTemplate</code> from reading the error object into a string.</p>

<p>Just for completeness, here&rsquo;s <code>RestUtil</code>:</p>

<pre><code>package myapp.util;

import org.springframework.http.HttpStatus;

public class RestUtil {

    public static boolean isError(HttpStatus status) {
        HttpStatus.Series series = status.series();
        return (HttpStatus.Series.CLIENT_ERROR.equals(series)
                || HttpStatus.Series.SERVER_ERROR.equals(series));
    }
}
</code></pre>

<p>Now we need to configure the <code>RestTemplate</code> to use our custom <code>ResponseErrorHandler</code>:</p>

<pre><code>&lt;bean class="org.springframework.web.client.RestTemplate"&gt;
    &lt;property name="errorHandler"&gt;
        &lt;bean class="myapp.client.MyResponseErrorHandler" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>We&rsquo;re going to need an object mapper too (I&rsquo;m assuming <a href="http://wiki.fasterxml.com/JacksonHome">Jackson 2</a> here, though in principle the same approach should work for JAXB or Jackson 1 as well). So here&rsquo;s that:</p>

<pre><code>&lt;bean id="objectMapper" class="com.fasterxml.jackson.databind.ObjectMapper" /&gt;
</code></pre>

<p>Inject the <code>RestTemplate</code> and <code>ObjectMapper</code> into your client code. Now here&rsquo;s how to use them to deal with error objects:</p>

<pre><code>@Inject private RestTemplate restTemplate;
@Inject private ObjectMapper objectMapper;

public DoodadResources getDoodads() {
    HttpHeaders headers = new HttpHeaders();
    headers.add("Accept", MediaType.APPLICATION_JSON_VALUE);
    HttpEntity&lt;String&gt; request = new HttpEntity&lt;String&gt;(headers);
    ResponseEntity&lt;String&gt; response =
            restTemplate.exchange(DOODAD_URL, HttpMethod.GET, request, String.class);
    String responseBody = response.getBody();
    try {
        if (RestUtil.isError(response.getStatusCode())) {
            MyErrorResource error = objectMapper.readValue(responseBody, MyErrorResource.class);
            throw new RestClientException("[" + error.getCode() + "] " + error.getMessage());
        } else {
            DoodadResources doodads = objectMapper.readValue(responseBody, DoodadResources.class);
            return doodads;
        }
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
</code></pre>

<p>Notice that the call to <code>exchange()</code> specifies that we want to map the response body to a string, which can handle any JSON (or XML) response. Then we use <code>RestUtil</code> again to process the response differently depending on the status series. For errors we parse the response body into a <code>MyErrorResource</code> and use it to throw an exception with an app-specific error code (not simply an HTTP status code) and a descriptive message. Of course we can do whatever we want with the detailed error information; this is just an example.</p>

<p>If there&rsquo;s no error, then we can parse the response body into the expected response type, if there is one, and return it. Here we return a <code>DoodadResources</code>.</p>

<h2>Conclusion</h2>

<p>Note that since we&rsquo;re capturing the JSON as a string, we&rsquo;re essentially buffering the entire response before parsing it into the actual object (whether expected or error). This may be inappropriate in cases involving large response payloads. Streaming works better there.</p>

<p>Personally I&rsquo;d like to see a version of <code>RestTemplate.exchange()</code> that supports two response types instead of just one: one for the expected response type and one for the error response type. This would avoid the need to handle error objects ourselves, and would also allow the <code>RestTemplate</code> to parse the response body (via Jackson) without having to buffer the entire thing first.</p>

<p>Anyway, that&rsquo;s at least one way to do it. If there are better ways I&rsquo;d very much appreciate hearing about them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick tip: Basic authentication with Spring RestTemplate]]></title>
    <link href="http://springinpractice.com/2013/10/02/quick-tip-basic-authentication-with-spring-resttemplate/"/>
    <updated>2013-10-02T02:10:00-07:00</updated>
    <id>http://springinpractice.com/2013/10/02/quick-tip-basic-authentication-with-spring-resttemplate</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s a quick tip for using Spring&rsquo;s <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a> to authenticate to a RESTful web service that uses <a href="http://en.wikipedia.org/wiki/Basic_access_authentication">HTTP basic authentication</a>.</p>

<p>There are a couple of things we have to do:</p>

<ul>
<li>First we construct an <code>Authorization</code> request header that contains (among other things) the user&rsquo;s base 64-encoded credentials.</li>
<li>Then we invoke the <code>RestTemplate</code> in such a way as to send that request header to the service.</li>
</ul>


<!-- more -->


<p>Let&rsquo;s start with the <code>Authorization</code> header.</p>

<h2>Authorization header</h2>

<p>For the sake of example, suppose that the username is <code>willie</code> and the password is <code>p@ssword</code>.</p>

<p>The first step is to base 64 encode the string <code>willie:p@ssword</code>. In general we want to do this programmatically. The <a href="http://commons.apache.org/proper/commons-codec/">Apache Commons Codec library</a> is useful for doing this:</p>

<pre><code>import org.apache.commons.codec.binary.Base64;

...

String plainCreds = "willie:p@ssword";
byte[] plainCredsBytes = plainCreds.getBytes();
byte[] base64CredsBytes = Base64.encodeBase64(plainCredsBytes);
String base64Creds = new String(base64CredsBytes);
</code></pre>

<p>Now let&rsquo;s construct our HTTP request headers, including the <code>Authorization</code> header:</p>

<pre><code>import org.springframework.http.HttpHeaders;

...

HttpHeaders headers = new HttpHeaders();
headers.add("Authorization", "Basic " + base64Creds);
</code></pre>

<p>Next, let&rsquo;s use the <code>RestTemplate</code> to issue the request.</p>

<h2>Using RestTemplate to send the request</h2>

<p>The approach is similar to what we did with <a href="http://springinpractice.com/2012/04/08/sending-cookies-with-resttemplate/">Sending Cookies with RestTemplate</a>. We use one of the <code>RestTemplate</code>&rsquo;s <code>exchange()</code> methods to exchange a request for a response. Let&rsquo;s imagine that we want to get account information.</p>

<pre><code>import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

...

HttpEntity&lt;String&gt; request = new HttpEntity&lt;String&gt;(headers);
ResponseEntity&lt;Account&gt; response = restTemplate.exchange(url, HttpMethod.GET, request, Account.class);
Account account = response.getBody();
</code></pre>

<p>In both the request and response, the type parameters represent the body. In the request we aren&rsquo;t sending anything in the body, so we just use <code>String</code> as a default, and pass the headers along by themselves. In the response we expect an account, so that&rsquo;s why we have <code>Account</code> and <code>Account.class</code> there.</p>

<p>Happy basic authenticating.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimistic locking with Spring Data REST]]></title>
    <link href="http://springinpractice.com/2013/09/14/optimistic-locking-with-spring-data-rest/"/>
    <updated>2013-09-14T20:43:00-07:00</updated>
    <id>http://springinpractice.com/2013/09/14/optimistic-locking-with-spring-data-rest</id>
    <content type="html"><![CDATA[<p>I&rsquo;m working on a web service for a document management system, where clients grab documents from the web service, modify them and submit the updates. Since multiple clients can all grab the same document at the same time, we needed to implement an <a href="http://c2.com/cgi/wiki?OptimisticLocking">optimistic locking</a> scheme. In this scheme, each document has a version number, and when the client submits an update to the service, the service checks to see whether the submitted version number baseline is still the most recent one in the database. If so, we increment the version number and the update proceeds. Otherwise, we throw an exception indicating a conflict.</p>

<!-- more -->


<p>From a technology perspective we&rsquo;re using <a href="http://projects.spring.io/spring-data-rest/">Spring Data REST</a>, <a href="http://projects.spring.io/spring-data-jpa/">Spring Data JPA</a>, JPA and Hibernate to implement the web service. So I originally tried to use <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Version.html">JPA&rsquo;s @Version annotation</a>. But for reasons I describe <a href="http://stackoverflow.com/questions/18780621/does-spring-data-rest-support-jpa-version">here</a> it doesn&rsquo;t work. <a href="https://twitter.com/mdeinum">Marten Deinum</a> notes further that this isn&rsquo;t really a problem with Spring Data REST <em>per se</em>; it affects e.g. form submissions too. At Marten&rsquo;s suggestion, I created an <a href="https://jira.springsource.org/browse/DATAREST-160">enhancement request</a>, but since I needed something now, I set out to implement optimisitic locking for Spring Data REST without <code>@Version</code>.</p>

<p>The trick is to listen for events that are fired before the update occurs. Spring Data REST fires such events, but so does JPA, and I decided to use JPA&rsquo;s events instead to ensure that the version number get/test/increment happens as part of a single atomic transaction. (My guess is that the Spring Data REST <a href="http://docs.spring.io/spring-data/rest/docs/1.1.0.M1/reference/htmlsingle/#events-chapter">BeforeSaveEvent</a> fires before entering the transaction.)</p>

<p>Here&rsquo;s the code. First, here&rsquo;s an interface for versioned entities.</p>

<pre><code>package myapp.entity;

public interface VersionedEntity {

    Long getVersion();

    void setVersion(Long version);
}
</code></pre>

<p>Next we have an abstract base class for versioned entities. I could have done a mixin-style implementation here (using, e.g., <a href="http://www.eclipse.org/aspectj/doc/next/progguide/language-interType.html">AspectJ inter-type declarations</a>), but I decided to keep it simple for now.</p>

<pre><code>package myapp.entity;

import javax.persistence.Column;
import javax.persistence.EntityListeners;
import javax.persistence.MappedSuperclass;
import myapp.repo.listener.OptimisticLockListener;

@MappedSuperclass
@EntityListeners(OptimisticLockListener.class)
public abstract class AbstractVersionedEntity implements VersionedEntity {

    @Column(name = "VERSION")
    private Long version;

    @Override
    public Long getVersion() { return version; }

    @Override
    public void setVersion(Long version) { this.version = version; }
}
</code></pre>

<p>Notice the <code>@EntityListeners</code> annotation. This tells JPA which class will listen for JPA lifecycle events. Here&rsquo;s the <code>OptimisticLockListener</code>.</p>

<pre><code>package myapp.repo.listener;

import javax.persistence.PreUpdate;
import org.springframework.stereotype.Component;
import myapp.entity.VersionedEntity;
import myapp.util.ApplicationContextProvider;

public class OptimisticLockListener {

    @PreUpdate
    public void preUpdate(Object entity) {
        if (entity instanceof VersionedEntity) {
            getChecker().check((VersionedEntity) entity);
        }
    }

    private OptimisticLockChecker getChecker() {
        return ApplicationContextProvider
            .getApplicationContext()
            .getBean(OptimisticLockChecker.class);
    }
}
</code></pre>

<p>In the listing above we grab an <code>OptimisticLockChecker</code> and then run the check. I&rsquo;ve implemented that as a separate class because I&rsquo;m going to need the application&rsquo;s <code>JdbcTemplate</code> to do the version check, and I need a managed bean to inject the <code>JdbcTemplate</code>. Unfortunately, <a href="http://stackoverflow.com/questions/12951701/how-to-get-entity-manager-or-transaction-in-jpa-listener">JPA 2.0 doesn&rsquo;t treat entity listeners as managed beans</a> (apparently that will change in JPA 2.1). That&rsquo;s why there&rsquo;s a separate <code>OptimisticLockChecker</code> class.</p>

<p><a href="https://twitter.com/vguhesan">Venkatt Guhesan</a> offers <code>ApplicationContextProvider</code> as a <a href="http://mythinkpond.wordpress.com/2010/03/22/spring-application-context/">clever way to get the app&rsquo;s context from an unmanaged instance</a>. Here&rsquo;s the technique.</p>

<pre><code>package myapp.util;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class ApplicationContextProvider implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

    public static ApplicationContext getApplicationContext() { return applicationContext; }

    @Override
    public void setApplicationContext(ApplicationContext appContext) throws BeansException {
        applicationContext = appContext;
    }
}
</code></pre>

<p>Finally, let&rsquo;s look at the <code>OptimisticLockChecker</code> itself.</p>

<pre><code>package myapp.repo.listener;

import java.lang.reflect.Field;
import javax.persistence.Column;
import javax.persistence.OptimisticLockException;
import javax.persistence.PersistenceContext;
import javax.persistence.Table;
import org.springframework.beans.BeanUtils;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.ReflectionUtils;
import myapp.entity.VersionedEntity;

@Component
public class OptimisticLockChecker {
    @Inject private JdbcTemplate jdbcTemplate;

    public void check(VersionedEntity entity) {
        Long submittedVersion = entity.getVersion();
        if (submittedVersion == null) {
            throw new RuntimeException("Submitted entity must have a version");
        }

        Class&lt;?&gt; entityClass = entity.getClass();

        Annotation tableAnn = AnnotationUtils.findAnnotation(entityClass, Table.class);
        String tableName = (String) AnnotationUtils.getValue(tableAnn, "name");

        Field idField = ReflectionUtils.findField(entityClass, "id");
        Annotation idColAnn = idField.getAnnotation(Column.class);
        String idColName = (String) AnnotationUtils.getValue(idColAnn, "name");

        String sql = "select version from " + tableName
            + " where " + idColName + "=" + entity.getId();
        Long latestVersion = jdbcTemplate.queryForObject(sql, Long.class);

        if (submittedVersion != latestVersion) {
            throw new OptimisticLockException(
                    "Stale entity: submitted version " + submittedVersion
                    + ", but latest version is " + latestVersion);
        }

        entity.setVersion(entity.getVersion() + 1);
    }
}
</code></pre>

<p>Despite appearances, the code is a little tricky because we&rsquo;re trying to compare an entity version in the persistence context with an entity version in the database, and by design JPA hides the database from the developer. There are different ways to achieve this, but the most straightforward and reliable is probably to use <code>JdbcTemplate</code> to get the latest version in the database. We use Spring&rsquo;s <code>AnnotationUtils</code> and <code>ReflectionUtils</code> to grab the table name and ID column name from the <code>@Table</code> and <code>@Column</code> annotations. (Note that the code above is for a <code>@Column</code> annotation defined on the field itself; if you&rsquo;ve defined <code>@Column</code> on the getter, then you can use <code>AnnotationUtils</code> to get at that.)</p>

<p>After that, we compare and either throw an exception or else increment the version number.</p>

<p>Perhaps the Spring Data REST guys will provide more direct support for <code>@Version</code> (or some suitable alternative) at some future point. Until then, I hope the approach above proves useful.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sending cookies with RestTemplate]]></title>
    <link href="http://springinpractice.com/2012/04/08/sending-cookies-with-resttemplate/"/>
    <updated>2012-04-08T14:06:18-07:00</updated>
    <id>http://springinpractice.com/2012/04/08/sending-cookies-with-resttemplate</id>
    <content type="html"><![CDATA[<p>Sometimes it is necessary to send cookies along with requests to a RESTful API. One such example is the JIRA 4.3 API, which requires sending the <code>JSESSIONID</code> to JIRA for session management and authentication purposes. REST purists point out that such usages are not properly RESTful (see <a href="http://blog.mikepearce.net/2010/08/24/cookies-and-the-restful-api/" target="_blank"><a href="http://blog.mikepearce.net/2010/08/24/cookies-and-the-restful-api/">http://blog.mikepearce.net/2010/08/24/cookies-and-the-restful-api/</a></a> for a good discussion), and indeed the <code>RestTemplate</code> doesn&rsquo;t directly support sending cookies.</p>

<p>But in the real world, we need to make things work, and so in this quick post I&rsquo;ll show how to send cookies with <code>RestTemplate</code>.</p>

<!-- more -->


<p>The first thing to bear in mind is that we implement cookies as HTTP headers: the service uses a <code>Set-Cookie</code> response header to tell the client to set a cookie, and the client uses the <code>Cookie</code> request header for subsequent requests. And <code>RestTemplate</code> certainly supports setting request headers.</p>

<p>Here&rsquo;s how I&rsquo;m pulling down an access-controlled RSS feed from JIRA 4.3:</p>

<pre>HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.add("Cookie", "JSESSIONID=" + session.getValue());
HttpEntity requestEntity = new HttpEntity(null, requestHeaders);
ResponseEntity rssResponse = restTemplate.exchange(
    "https://jira.example.com/sr/jira.issueviews:searchrequest-xml/18107/SearchRequest-18107.xml?tempMax=1000",
    HttpMethod.GET,
    requestEntity,
    Rss.class);
Rss rss = rssResponse.getBody();</pre>


<p>The trick here is to use the <code>RestTemplate</code>&rsquo;s <code>exchange()</code> method, as this gives us more control over the request, including request headers. We just encode the cookie as a <code>JSESSIONID=[session ID]</code> request header and send it along.</p>

<p>Have fun!</p>
]]></content>
  </entry>
  
</feed>
