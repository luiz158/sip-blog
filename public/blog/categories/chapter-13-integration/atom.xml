<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chapter 13 - Integration | Spring in Practice]]></title>
  <link href="http://springinpractice.com/blog/categories/chapter-13-integration/atom.xml" rel="self"/>
  <link href="http://springinpractice.com/"/>
  <updated>2013-10-02T03:10:48-07:00</updated>
  <id>http://springinpractice.com/</id>
  <author>
    <name><![CDATA[Willie Wheeler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quick tip: Basic authentication with Spring RestTemplate]]></title>
    <link href="http://springinpractice.com/2013/10/02/quick-tip-basic-authentication-with-spring-resttemplate/"/>
    <updated>2013-10-02T02:10:00-07:00</updated>
    <id>http://springinpractice.com/2013/10/02/quick-tip-basic-authentication-with-spring-resttemplate</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s a quick tip for using Spring&rsquo;s <a href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a> to authenticate to a RESTful web service that uses <a href="http://en.wikipedia.org/wiki/Basic_access_authentication">HTTP basic authentication</a>.</p>

<p>There are a couple of things we have to do:</p>

<ul>
<li>First we construct an <code>Authorization</code> request header that contains (among other things) the user&rsquo;s base 64-encoded credentials.</li>
<li>Then we invoke the <code>RestTemplate</code> in such a way as to send that request header to the service.</li>
</ul>


<!-- more -->


<p>Let&rsquo;s start with the <code>Authorization</code> header.</p>

<h2>Authorization header</h2>

<p>For the sake of example, suppose that the username is <code>willie</code> and the password is <code>p@ssword</code>.</p>

<p>The first step is to base 64 encode the string <code>willie:p@ssword</code>. In general we want to do this programmatically. The <a href="http://commons.apache.org/proper/commons-codec/">Apache Commons Codec library</a> is useful for doing this:</p>

<pre><code>import org.apache.commons.codec.binary.Base64;

...

String plainCreds = "willie:p@ssword";
byte[] plainCredsBytes = plainCreds.getBytes();
byte[] base64CredsBytes = Base64.encodeBase64(plainCredsBytes);
String base64Creds = new String(base64CredsBytes);
</code></pre>

<p>Now let&rsquo;s construct our HTTP request headers, including the <code>Authorization</code> header:</p>

<pre><code>import org.springframework.http.HttpHeaders;

...

HttpHeaders headers = new HttpHeaders();
headers.add("Authorization", "Basic " + base64Creds);
</code></pre>

<p>Next, let&rsquo;s use the <code>RestTemplate</code> to issue the request.</p>

<h2>Using RestTemplate to send the request</h2>

<p>The approach is similar to what we did with <a href="http://springinpractice.com/2012/04/08/sending-cookies-with-resttemplate/">Sending Cookies with RestTemplate</a>. We use one of the <code>RestTemplate</code>&rsquo;s <code>exchange()</code> methods to exchange a request for a response. Let&rsquo;s imagine that we want to get account information.</p>

<pre><code>import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

...

HttpEntity&lt;String&gt; request = new HttpEntity&lt;String&gt;(headers);
ResponseEntity&lt;Account&gt; response = restTemplate.exchange(url, HttpMethod.GET, request, Account.class);
Account account = response.getBody();
</code></pre>

<p>In both the request and response, the type parameters represent the body. In the request we aren&rsquo;t sending anything in the body, so we just use <code>String</code> as a default, and pass the headers along by themselves. In the response we expect an account, so that&rsquo;s why we have <code>Account</code> and <code>Account.class</code> there.</p>

<p>Happy basic authenticating.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimistic locking with Spring Data REST]]></title>
    <link href="http://springinpractice.com/2013/09/14/optimistic-locking-with-spring-data-rest/"/>
    <updated>2013-09-14T20:43:00-07:00</updated>
    <id>http://springinpractice.com/2013/09/14/optimistic-locking-with-spring-data-rest</id>
    <content type="html"><![CDATA[<p>I&rsquo;m working on a web service for a document management system, where clients grab documents from the web service, modify them and submit the updates. Since multiple clients can all grab the same document at the same time, we needed to implement an <a href="http://c2.com/cgi/wiki?OptimisticLocking">optimistic locking</a> scheme. In this scheme, each document has a version number, and when the client submits an update to the service, the service checks to see whether the submitted version number baseline is still the most recent one in the database. If so, we increment the version number and the update proceeds. Otherwise, we throw an exception indicating a conflict.</p>

<!-- more -->


<p>From a technology perspective we&rsquo;re using <a href="http://projects.spring.io/spring-data-rest/">Spring Data REST</a>, <a href="http://projects.spring.io/spring-data-jpa/">Spring Data JPA</a>, JPA and Hibernate to implement the web service. So I originally tried to use <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Version.html">JPA&rsquo;s @Version annotation</a>. But for reasons I describe <a href="http://stackoverflow.com/questions/18780621/does-spring-data-rest-support-jpa-version">here</a> it doesn&rsquo;t work. <a href="https://twitter.com/mdeinum">Marten Deinum</a> notes further that this isn&rsquo;t really a problem with Spring Data REST <em>per se</em>; it affects e.g. form submissions too. At Marten&rsquo;s suggestion, I created an <a href="https://jira.springsource.org/browse/DATAREST-160">enhancement request</a>, but since I needed something now, I set out to implement optimisitic locking for Spring Data REST without <code>@Version</code>.</p>

<p>The trick is to listen for events that are fired before the update occurs. Spring Data REST fires such events, but so does JPA, and I decided to use JPA&rsquo;s events instead to ensure that the version number get/test/increment happens as part of a single atomic transaction. (My guess is that the Spring Data REST <a href="http://docs.spring.io/spring-data/rest/docs/1.1.0.M1/reference/htmlsingle/#events-chapter">BeforeSaveEvent</a> fires before entering the transaction.)</p>

<p>Here&rsquo;s the code. First, here&rsquo;s an interface for versioned entities.</p>

<pre><code>package myapp.entity;

public interface VersionedEntity {

    Long getVersion();

    void setVersion(Long version);
}
</code></pre>

<p>Next we have an abstract base class for versioned entities. I could have done a mixin-style implementation here (using, e.g., <a href="http://www.eclipse.org/aspectj/doc/next/progguide/language-interType.html">AspectJ inter-type declarations</a>), but I decided to keep it simple for now.</p>

<pre><code>package myapp.entity;

import javax.persistence.Column;
import javax.persistence.EntityListeners;
import javax.persistence.MappedSuperclass;
import myapp.repo.listener.OptimisticLockListener;

@MappedSuperclass
@EntityListeners(OptimisticLockListener.class)
public abstract class AbstractVersionedEntity implements VersionedEntity {

    @Column(name = "VERSION")
    private Long version;

    @Override
    public Long getVersion() { return version; }

    @Override
    public void setVersion(Long version) { this.version = version; }
}
</code></pre>

<p>Notice the <code>@EntityListeners</code> annotation. This tells JPA which class will listen for JPA lifecycle events. Here&rsquo;s the <code>OptimisticLockListener</code>.</p>

<pre><code>package myapp.repo.listener;

import javax.persistence.PreUpdate;
import org.springframework.stereotype.Component;
import myapp.entity.VersionedEntity;
import myapp.util.ApplicationContextProvider;

public class OptimisticLockListener {

    @PreUpdate
    public void preUpdate(Object entity) {
        if (entity instanceof VersionedEntity) {
            getChecker().check((VersionedEntity) entity);
        }
    }

    private OptimisticLockChecker getChecker() {
        return ApplicationContextProvider
            .getApplicationContext()
            .getBean(OptimisticLockChecker.class);
    }
}
</code></pre>

<p>In the listing above we grab an <code>OptimisticLockChecker</code> and then run the check. I&rsquo;ve implemented that as a separate class because I&rsquo;m going to need the application&rsquo;s <code>JdbcTemplate</code> to do the version check, and I need a managed bean to inject the <code>JdbcTemplate</code>. Unfortunately, <a href="http://stackoverflow.com/questions/12951701/how-to-get-entity-manager-or-transaction-in-jpa-listener">JPA 2.0 doesn&rsquo;t treat entity listeners as managed beans</a> (apparently that will change in JPA 2.1). That&rsquo;s why there&rsquo;s a separate <code>OptimisticLockChecker</code> class.</p>

<p><a href="https://twitter.com/vguhesan">Venkatt Guhesan</a> offers <code>ApplicationContextProvider</code> as a <a href="http://mythinkpond.wordpress.com/2010/03/22/spring-application-context/">clever way to get the app&rsquo;s context from an unmanaged instance</a>. Here&rsquo;s the technique.</p>

<pre><code>package myapp.util;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class ApplicationContextProvider implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

    public static ApplicationContext getApplicationContext() { return applicationContext; }

    @Override
    public void setApplicationContext(ApplicationContext appContext) throws BeansException {
        applicationContext = appContext;
    }
}
</code></pre>

<p>Finally, let&rsquo;s look at the <code>OptimisticLockChecker</code> itself.</p>

<pre><code>package myapp.repo.listener;

import java.lang.reflect.Field;
import javax.persistence.Column;
import javax.persistence.OptimisticLockException;
import javax.persistence.PersistenceContext;
import javax.persistence.Table;
import org.springframework.beans.BeanUtils;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.ReflectionUtils;
import myapp.entity.VersionedEntity;

@Component
public class OptimisticLockChecker {
    @Inject private JdbcTemplate jdbcTemplate;

    public void check(VersionedEntity entity) {
        Long submittedVersion = entity.getVersion();
        if (submittedVersion == null) {
            throw new RuntimeException("Submitted entity must have a version");
        }

        Class&lt;?&gt; entityClass = entity.getClass();

        Annotation tableAnn = AnnotationUtils.findAnnotation(entityClass, Table.class);
        String tableName = (String) AnnotationUtils.getValue(tableAnn, "name");

        Field idField = ReflectionUtils.findField(entityClass, "id");
        Annotation idColAnn = idField.getAnnotation(Column.class);
        String idColName = (String) AnnotationUtils.getValue(idColAnn, "name");

        String sql = "select version from " + tableName
            + " where " + idColName + "=" + entity.getId();
        Long latestVersion = jdbcTemplate.queryForObject(sql, Long.class);

        if (submittedVersion != latestVersion) {
            throw new OptimisticLockException(
                    "Stale entity: submitted version " + submittedVersion
                    + ", but latest version is " + latestVersion);
        }

        entity.setVersion(entity.getVersion() + 1);
    }
}
</code></pre>

<p>Despite appearances, the code is a little tricky because we&rsquo;re trying to compare an entity version in the persistence context with an entity version in the database, and by design JPA hides the database from the developer. There are different ways to achieve this, but the most straightforward and reliable is probably to use <code>JdbcTemplate</code> to get the latest version in the database. We use Spring&rsquo;s <code>AnnotationUtils</code> and <code>ReflectionUtils</code> to grab the table name and ID column name from the <code>@Table</code> and <code>@Column</code> annotations. (Note that the code above is for a <code>@Column</code> annotation defined on the field itself; if you&rsquo;ve defined <code>@Column</code> on the getter, then you can use <code>AnnotationUtils</code> to get at that.)</p>

<p>After that, we compare and either throw an exception or else increment the version number.</p>

<p>Perhaps the Spring Data REST guys will provide more direct support for <code>@Version</code> (or some suitable alternative) at some future point. Until then, I hope the approach above proves useful.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sending cookies with RestTemplate]]></title>
    <link href="http://springinpractice.com/2012/04/08/sending-cookies-with-resttemplate/"/>
    <updated>2012-04-08T14:06:18-07:00</updated>
    <id>http://springinpractice.com/2012/04/08/sending-cookies-with-resttemplate</id>
    <content type="html"><![CDATA[<p>Sometimes it is necessary to send cookies along with requests to a RESTful API. One such example is the JIRA 4.3 API, which requires sending the <code>JSESSIONID</code> to JIRA for session management and authentication purposes. REST purists point out that such usages are not properly RESTful (see <a href="http://blog.mikepearce.net/2010/08/24/cookies-and-the-restful-api/" target="_blank"><a href="http://blog.mikepearce.net/2010/08/24/cookies-and-the-restful-api/">http://blog.mikepearce.net/2010/08/24/cookies-and-the-restful-api/</a></a> for a good discussion), and indeed the <code>RestTemplate</code> doesn&rsquo;t directly support sending cookies.</p>

<p>But in the real world, we need to make things work, and so in this quick post I&rsquo;ll show how to send cookies with <code>RestTemplate</code>.</p>

<!-- more -->


<p>The first thing to bear in mind is that we implement cookies as HTTP headers: the service uses a <code>Set-Cookie</code> response header to tell the client to set a cookie, and the client uses the <code>Cookie</code> request header for subsequent requests. And <code>RestTemplate</code> certainly supports setting request headers.</p>

<p>Here&rsquo;s how I&rsquo;m pulling down an access-controlled RSS feed from JIRA 4.3:</p>

<pre>HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.add("Cookie", "JSESSIONID=" + session.getValue());
HttpEntity requestEntity = new HttpEntity(null, requestHeaders);
ResponseEntity rssResponse = restTemplate.exchange(
    "https://jira.example.com/sr/jira.issueviews:searchrequest-xml/18107/SearchRequest-18107.xml?tempMax=1000",
    HttpMethod.GET,
    requestEntity,
    Rss.class);
Rss rss = rssResponse.getBody();</pre>


<p>The trick here is to use the <code>RestTemplate</code>&rsquo;s <code>exchange()</code> method, as this gives us more control over the request, including request headers. We just encode the cookie as a <code>JSESSIONID=[session ID]</code> request header and send it along.</p>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Spring Social GitHub to access secured GitHub data]]></title>
    <link href="http://springinpractice.com/2012/03/06/using-spring-social-github-to-access-secured-github-data-code/"/>
    <updated>2012-03-06T04:40:28-08:00</updated>
    <id>http://springinpractice.com/2012/03/06/using-spring-social-github-to-access-secured-github-data-code</id>
    <content type="html"><![CDATA[<p>In <a href="http://springinpractice.com/2012/03/06/zkybase-now-supports-authorized-access-to-github-via-spring-social-github/">this post</a>, I shared some screenshots of an open source, Spring-based CMDB I&rsquo;m building called <a title="Zkybase GitHub site" href="https://github.com/williewheeler/zkybase">Zkybase</a>. In the current post I want to show some of the code and configuration that&rsquo;s required to make OAuth2-authorized Spring/GitHub integration work.</p>

<!-- more -->


<p><img src="http://springinpractice.s3.amazonaws.com/blog/images/2012-03-06-using-spring-social-github-to-access-secured-github-data-code/hooks2.png" alt="Zkybase screenshot" /></p>

<h3>Spring application configuration</h3>


<p>This goes in the app context. I lifted it more or less as-is from the Spring Social reference documentation, except that I&rsquo;m using GitHub as the provider instead of Facebook, Twitter or LinkedIn.</p>

<pre>&lt;bean id="connectionFactoryLocator" class="org.springframework.social.connect.support.ConnectionFactoryRegistry"&gt;
    &lt;property name="connectionFactories"&gt;
        &lt;list&gt;
            &lt;bean class="org.springframework.social.github.connect.GitHubConnectionFactory"&gt;
                &lt;constructor-arg value="${gitHub.clientId}" /&gt;
                &lt;constructor-arg value="${gitHub.clientSecret}" /&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="noOpText" /&gt;

&lt;bean id="usersConnectionRepository" class="org.springframework.social.connect.jdbc.JdbcUsersConnectionRepository"&gt;
    &lt;constructor-arg ref="dataSource" /&gt;
    &lt;constructor-arg ref="connectionFactoryLocator" /&gt;
    &lt;constructor-arg ref="textEncryptor" /&gt;
&lt;/bean&gt;

&lt;!-- This requires authentication via Spring Security --&gt;
&lt;bean id="connectionRepository"
    factory-bean="usersConnectionRepository"
    factory-method="createConnectionRepository" 
    scope="request"&gt;
    
    &lt;constructor-arg value="#{request.userPrincipal.name}" /&gt;
    &lt;aop:scoped-proxy proxy-target-class="false" /&gt;
&lt;/bean&gt;</pre>




<h3>Spring web configuration</h3>




<pre>&lt;bean class="org.springframework.social.connect.web.ConnectController" /&gt;</pre>




<h3>Service code for the user account page</h3>


<p>Here&rsquo;s how I&rsquo;m looking up the GitHub user profile information:</p>

<pre>package org.skydingo.zkybase.service.impl;

import javax.inject.Inject;

import org.skydingo.zkybase.model.UserAccount;
import org.skydingo.zkybase.repository.UserAccountRepository;
import org.skydingo.zkybase.service.UserAccountService;
import org.springframework.social.connect.Connection;
import org.springframework.social.connect.ConnectionRepository;
import org.springframework.social.github.api.GitHub;
import org.springframework.social.github.api.GitHubUserProfile;
import org.springframework.social.github.api.impl.GitHubTemplate;
import org.springframework.stereotype.Service;

@Service
public class UserAccountServiceImpl extends AbstractCIService implements UserAccountService {
    @Inject private ConnectionRepository connectionRepo;
    
    public GitHubUserProfile getCurrentUserProfile() {
        if (gitHub().isAuthorized()) {
            return gitHub().userOperations().getUserProfile();
        } else {
            return null;
        }
    }
    
    private GitHub gitHub() {
        Connection conn = connectionRepo.findPrimaryConnection(GitHub.class);
        return (conn != null ? conn.getApi() : new GitHubTemplate());
    }

    ... other methods ...
}</pre>


<p>In the <code>gitHub()</code> method you can see that I return an existing <code>GitHub</code> object if the connection exists; otherwise I just create a new <code>GitHub</code> (in the form of the template, which implements <code>GitHub</code>) so that the app can at least perform non-sensitive read operations.</p>

<h3>Service to get the GitHub service hooks</h3>


<p>This one&rsquo;s pretty similar to the above.</p>

<pre>package org.skydingo.zkybase.service.impl;

import java.util.List;
import javax.inject.Inject;
import org.skydingo.zkybase.model.Application;
import org.skydingo.zkybase.service.ApplicationService;
import org.springframework.social.connect.Connection;
import org.springframework.social.connect.ConnectionRepository;
import org.springframework.social.github.api.GitHub;
import org.springframework.social.github.api.GitHubHook;
import org.springframework.social.github.api.impl.GitHubTemplate;
import org.springframework.stereotype.Service;

@Service
public class ApplicationServiceImpl extends AbstractCIService implements ApplicationService {
    @Inject private ConnectionRepository connectionRepo;
    
    public List findHooks(String user, String repo) {
        return gitHub().repoOperations().getHooks(user, repo);
    }

    private GitHub gitHub() {
        Connection conn = connectionRepo.findPrimaryConnection(GitHub.class);
        return (conn != null ? conn.getApi() : new GitHubTemplate());
    }

    ... various other methods ...
}</pre>


<p>I should probably factor out that common <code>gitHub()</code> method. :&ndash;)</p>

<h3>User account JSP</h3>


<p>Here&rsquo;s the JSP code for rendering the connect/disconnect buttons. The CSS classes come from <a title="Twitter Bootstrap" href="http://twitter.github.com/bootstrap/">Bootstrap 2.0</a>, in case you were wondering.</p>

<pre>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %&gt;
&lt;%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %&gt;
&lt;%@ taglib prefix="social" uri="http://www.springframework.org/spring-social/social/tags" %&gt;

&lt;c:url var="connectUrl" value="/connect" /&gt;
&lt;c:url var="githubUrl" value="/connect/github" /&gt;

&lt;sec:authentication var="user" property="principal" /&gt;

&lt;h1&gt;Account details&lt;/h1&gt;

&lt;section class="first"&gt;
    &lt;div class="well"&gt;
        &lt;table class="grid"&gt;
            &lt;tr&gt;
                &lt;td&gt;Username:&lt;/td&gt;
                &lt;td&gt;&lt;c:out value="${user.username}" /&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/section&gt;

&lt;section&gt;
    &lt;h2&gt;GitHub&lt;/h2&gt;

    &lt;social:connected provider="github"&gt;
        &lt;p&gt;Your Zkybase and GitHub accounts are connected.&lt;/p&gt;
        &lt;div class="well"&gt;
            &lt;table class="grid"&gt;
                &lt;tr&gt;
                    &lt;td&gt;Blog:&lt;/td&gt;
                    &lt;td&gt;&lt;c:out value="${gitHubUserProfile.blog}" default="None" /&gt;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td&gt;Location:&lt;/td&gt;
                    &lt;td&gt;&lt;c:out value="${gitHubUserProfile.location}" default="None" /&gt;&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;
        &lt;form method="post" action="${githubUrl}"&gt;
            &lt;input type="hidden" name="_method" value="delete" /&gt;
            &lt;input class="btn btn-danger" type="submit" value="Disconnect from GitHub" /&gt;
        &lt;/form&gt;
    &lt;/social:connected&gt;

    &lt;social:notConnected provider="github"&gt;
        &lt;p&gt;Your Zkybase and GitHub accounts are not yet connected. Connect them for additional Zkybase features.&lt;/p&gt;
        &lt;form method="post" action="${githubUrl}"&gt;
            &lt;input type="hidden" name="scope" value="user, repo, gist" /&gt;
            &lt;input class="btn btn-primary" type="submit" value="Connect to GitHub" /&gt;
        &lt;/form&gt;
    &lt;/social:notConnected&gt;
&lt;/section&gt;</pre>


<p>Note the use of the Spring Social <code>&lt;social:connected&gt;</code> and <code>&lt;social:notConnected&gt;</code> tags to show different content based on whether the user is or isn&rsquo;t connected to the provider in question.</p>

<p>Notice also that the connect button sends a hidden <code>scope</code> parameter to the GitHub URL. This allows us to specify the kinds of operation we want the user to authorize.</p>

<p>Anyway, there you have it. This post was a bit quick, so let me know if I left anything important out and I&rsquo;m happy to add it. Have fun.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Supporting XML and JSON web service endpoints in Spring 3.1 using @ResponseBody]]></title>
    <link href="http://springinpractice.com/2012/02/22/supporting-xml-and-json-web-service-endpoints-in-spring-3-1-using-responsebody/"/>
    <updated>2012-02-22T04:21:32-08:00</updated>
    <id>http://springinpractice.com/2012/02/22/supporting-xml-and-json-web-service-endpoints-in-spring-3-1-using-responsebody</id>
    <content type="html"><![CDATA[<p>In <a href="http://springinpractice.com/2011/12/06/jackson-json-jaxb2-xml-spring/" title="Configuring Jackson to use JAXB2 annotations with Spring">an earlier post</a> I explained how to avoid parallel JAXB2/Jackson annotations when supporting both XML and JSON web service endpoints. Basically the idea was to configure the Jackson <code>ObjectMapper</code> to understand JAXB2 annotations.</p>

<!-- more -->




<h3>The problem</h3>


<p>One of the things that was a little unsatisfactory about that post was that I was using views to generate the XML and JSON representations. We can do that, of course, but a more direct approach to generating the desired data payloads is to use <code>@ResponseBody</code> in conjunction with Spring&rsquo;s <code>HttpMessageConverter</code>s. The idea here is that handler methods simply return the object to be mapped (whether to XML or to JSON), and then HTTP message converters sitting on the app context map the object to XML or JSON. Correspondingly, there are HTTP message converters for both JAXB2 and Jackson (among several others). I say this is more direct because there&rsquo;s no need to involve a model or a view at all: the controller simply returns the object and the converters do the rest.</p>

<p>In Spring 3.0 this was somewhat challenging to pull off, because both the JAXB2 message converter and the Jackson message converter are able to map the object, and so whichever message converter appears first in the list (the JAXB2 converter, it seems) would always map the object. So we ended up either having to treat JSON as a special case (invoke the <code>ObjectMapper</code> directly), or else just use views after all.</p>

<p>In Spring 3.1 things are a lot better: we can use the <code>@ResponseBody</code> and HTTP message converter approach quite cleanly, owing to an enhancement to <code>@RequestMapping</code> and also to an enhancement to the <code>&lt;mvc:annotation-driven&gt;</code> configuration.</p>

<p>Let&rsquo;s see how it works.</p>

<h3>Implementing the controller</h3>


<p>We&rsquo;ll look at the controller code first:</p>

<pre>@RequestMapping(
    value = "/{id}.json",
    method = RequestMethod.GET,
    produces = "application/json")
@ResponseBody
public Person getDetailsAsJson(@PathVariable Long id) {
    return personRepo.findOne(id);
}

@RequestMapping(
    value = "/{id}.xml",
    method = RequestMethod.GET,
    produces = "application/xml")
@ResponseBody
public Person getDetailsAsXml(@PathVariable Long id) {
    return personRepo.findOne(id);
}</pre>


<p>To use the <code>@ResponseBody</code> approach, we obviously need to annotate the handler methods with that annotation, so that&rsquo;s what we&rsquo;ve done here. The other thing we do here is return the actual entity (in this case, a <code>Person</code>) from the method instead of returning a logical view name.</p>

<p>We&rsquo;ve also specified the extension (either <code>.json</code> or <code>.xml</code>) in the value to route requests correctly.</p>

<p>So far, everything we&#039;ve described was available in Spring 3.0. But notice the new <code>produces</code> element, introduced with Spring 3.1, in the <code>@RequestMapping</code> annotation. This element has two effects. First, it excludes requests with <code>Accepts</code> headers incompatible with the specified media type. Second, it ensures that the generated response is consistent with the specified media type. It&rsquo;s this second effect that we care about, because this is what allows Spring to figure out which HTTP message converter to use, even when we&rsquo;re using JAXB2 annotations for both XML and JSON mapping.</p>

<h3>Configuration</h3>


<p>We need some configuration too. Here are the relevant bits. Be sure you&rsquo;re using Spring 3.1, that you&rsquo;ve declared the <code>oxm</code> and <code>mvc</code> namespaces, etc.</p>

<pre>&lt;oxm:jaxb2-marshaller id="marshaller"&gt;
    &lt;oxm:class-to-be-bound name="org.skydingo.skybase.model.Person" /&gt;
&lt;/oxm:jaxb2-marshaller&gt;
    
&lt;bean id="jaxbAnnIntrospector" class="org.codehaus.jackson.xc.JaxbAnnotationIntrospector" /&gt;
&lt;bean id="jacksonObjectMapper" class="org.codehaus.jackson.map.ObjectMapper"&gt;
    &lt;property name="serializationConfig.annotationIntrospector" ref="jaxbAnnIntrospector" /&gt;
    &lt;property name="deserializationConfig.annotationIntrospector" ref="jaxbAnnIntrospector" /&gt;
&lt;/bean&gt;

&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters&gt;
        &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"
            p:objectMapper-ref="jacksonObjectMapper" /&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;</pre>


<p>The JAXB2 marshaller and Jackson <code>ObjectMapper</code> are the same as they were in my earlier post. The thing that&rsquo;s different is the <code>&lt;mvc:annotation-driven&gt;</code> definition, and specifically, my inclusion of the new Spring 3.1 <code>&lt;mvc:message-converters&gt;</code> configuration. This allows us to define converters that override the defaults. Here I want to override the default Jackson converter with one that knows about my JAXB2-enabled <code>ObjectMapper</code>.</p>

<p>You don&rsquo;t need to include XML or JSON views anymore. If you don&rsquo;t have anything other than the normal JSP view, you can probably get rid of the <code>ContentNegotiatingViewResolver</code> entirely.</p>

<h3>The end result</h3>


<p>The result is that we can now generate XML and JSON payloads in a simple and consistent fashion. There&rsquo;s no more need for models and views here (at least with respect to generating XML and JSON), and there&rsquo;s no need to invoke <code>ObjectMapper</code>s directly or anything like that.</p>
]]></content>
  </entry>
  
</feed>
